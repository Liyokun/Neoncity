<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üåÉ Cyberpunk Street Walk - Fixed</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            touch-action: none; font-family: 'Courier New', monospace;
        }
        #joystick-zone { 
            position: absolute; bottom: 50px; left: 50px; 
            width: 120px; height: 120px; z-index: 100; opacity: 0.8; 
        }
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, #0a0a1f 0%, #000000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999; transition: opacity 1s;
        }
        #loading h1 {
            color: #00f2ff; font-size: 2em; text-shadow: 0 0 20px #00f2ff; margin-bottom: 20px;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }
        #info {
            position: absolute; top: 20px; left: 20px; color: #ff006e;
            background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #ff006e;
            border-radius: 8px; font-size: 14px; z-index: 10;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h1>‚ö° SYSTEM BOOTING... ‚ö°</h1>
    </div>
    <div id="info">
        <div>üïπÔ∏è MOVEMENT: WASD / Joystick</div>
        <div>üëÄ LOOK: Drag Screen</div>
    </div>
    <div id="joystick-zone"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script type="module">
        import * as THREE from 'three';

        // === 1. SETUP ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.035); // S∆∞∆°ng m√π d√†y h∆°n ch√∫t

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // === 2. SKYBOX (FIX LOAD & FALLBACK) ===
        const loader = new THREE.TextureLoader();
        
        const hideLoading = () => {
            const el = document.getElementById('loading');
            if(el) { el.style.opacity = '0'; setTimeout(() => el.style.display = 'none', 1000); }
        };

        // Th√™m ./ ƒë·ªÉ ƒë·ªãnh v·ªã file, th√™m x·ª≠ l√Ω l·ªói
        loader.load('./neoncity0.webp', 
            (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                const skybox = new THREE.Mesh(
                    new THREE.SphereGeometry(100, 64, 32),
                    new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide })
                );
                scene.add(skybox);
                hideLoading();
            },
            undefined, 
            (err) => {
                console.warn("·∫¢nh l·ªói, d√πng sao tr·ªùi thay th·∫ø.");
                const starGeo = new THREE.BufferGeometry();
                const starCnt = 2000;
                const starPos = new Float32Array(starCnt * 3);
                for(let i=0; i<starCnt*3; i++) starPos[i] = (Math.random() - 0.5) * 200;
                starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
                const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.5}));
                scene.add(stars);
                hideLoading();
            }
        );

        // === 3. M·∫∂T ƒê∆Ø·ªúNG TH·ª∞C T·∫æ (S·ª¨A L·ªñI PI V√Ä V·∫¨T LI·ªÜU) ===
        // T·∫°o v√¢n nh√°m (Noise Texture) b·∫±ng code
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#111'; ctx.fillRect(0,0,512,512);
        for(let i=0; i<50000; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#222' : '#000';
            ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
        }
        const noiseTex = new THREE.CanvasTexture(canvas);
        noiseTex.wrapS = noiseTex.wrapT = THREE.RepeatWrapping;
        noiseTex.repeat.set(8, 8);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 60),
            new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a, 
                roughness: 0.2, 
                metalness: 0.6, 
                roughnessMap: noiseTex // Th√™m v√¢n nh√°m
            })
        );
        // S·ª¨A L·ªñI QUAN TR·ªåNG: Math.PI thay v√¨ Math.PIcenter
        ground.rotation.x = -Math.PI / 2; 
        ground.receiveShadow = true;
        scene.add(ground);

        // V≈©ng n∆∞·ªõc
        const puddles = [
            { x: 3, z: 2, r: 2 }, { x: -4, z: -3, r: 1.5 },
            { x: 5, z: -5, r: 1.8 }, { x: -6, z: 4, r: 2.2 }
        ];
        puddles.forEach(p => {
            const puddle = new THREE.Mesh(
                new THREE.CircleGeometry(p.r, 32),
                new THREE.MeshStandardMaterial({
                    color: 0x000510, roughness: 0.05, metalness: 0.9
                })
            );
            puddle.rotation.x = -Math.PI / 2;
            puddle.position.set(p.x, 0.01, p.z);
            scene.add(puddle);
        });

        // B·ªè Grid Xanh l√°, thay b·∫±ng v·∫°ch k·∫ª ƒë∆∞·ªùng m·ªù
        const roadMarking = new THREE.GridHelper(60, 10, 0x333333, 0x111111);
        roadMarking.position.y = 0.005;
        scene.add(roadMarking);

        // === 4. T∆Ø·ªúNG CH·∫∂N (GI·ªÆ NGUY√äN) ===
        const walls = [
            new THREE.Mesh(new THREE.BoxGeometry(1, 5, 20), new THREE.MeshBasicMaterial({visible:false})),
            new THREE.Mesh(new THREE.BoxGeometry(1, 5, 20), new THREE.MeshBasicMaterial({visible:false})),
            new THREE.Mesh(new THREE.BoxGeometry(20, 5, 1), new THREE.MeshBasicMaterial({visible:false})),
            new THREE.Mesh(new THREE.BoxGeometry(20, 5, 1), new THREE.MeshBasicMaterial({visible:false}))
        ];
        walls[0].position.set(-10, 2.5, 0);
        walls[1].position.set(10, 2.5, 0);
        walls[2].position.set(0, 2.5, -10);
        walls[3].position.set(0, 2.5, 10);
        walls.forEach(w => { w.userData.isWall = true; scene.add(w); });

        // === 5. ƒê√àN ƒê∆Ø·ªúNG (GI·ªÆ NGUY√äN) ===
        const posts = [[-8, -8], [8, -8], [-8, 8], [8, 8]];
        const lights = [];

        posts.forEach((pos, i) => {
            const pole = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 5, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 })
            );
            pole.position.set(pos[0], 2.5, pos[1]);
            pole.castShadow = true;
            scene.add(pole);

            const color = i % 2 == 0 ? 0xff006e : 0x00f2ff;
            const bulb = new THREE.PointLight(color, 200, 15);
            bulb.position.set(pos[0], 4.5, pos[1]);
            bulb.castShadow = true;
            scene.add(bulb);

            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.5),
                new THREE.MeshBasicMaterial({ color: color })
            );
            glow.position.copy(bulb.position);
            scene.add(glow);
            lights.push({l: bulb, c: color});
        });

        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        // M∆∞a
        const rainGeo = new THREE.BufferGeometry();
        const rCount = 3000;
        const rPos = new Float32Array(rCount*3);
        for(let i=0; i<rCount*3; i+=3) {
            rPos[i] = (Math.random()-0.5)*40;
            rPos[i+1] = Math.random()*20;
            rPos[i+2] = (Math.random()-0.5)*40;
        }
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rPos, 3));
        const rainSys = new THREE.Points(rainGeo, new THREE.PointsMaterial({color: 0x8888aa, size: 0.1, transparent:true, opacity:0.6}));
        scene.add(rainSys);

        // === 6. ƒêI·ªÄU KHI·ªÇN & LOGIC (GI·ªÆ NGUY√äN) ===
        let move = { f: 0, r: 0 }, look = { x: 0, y: 0 };
        let interact = false, start = { x: 0, y: 0, lx: 0, ly: 0 };

        const joy = nipplejs.create({ zone: document.getElementById('joystick-zone'), mode: 'static', position: {left: '60px', bottom: '60px'}, color: 'cyan' });
        joy.on('move', (e, d) => { move.f = d.vector.y; move.r = d.vector.x; });
        joy.on('end', () => { move.f = 0; move.r = 0; });

        document.addEventListener('pointerdown', e => { 
            if(e.clientX > window.innerWidth/2) { interact = true; start = {x: e.clientX, y: e.clientY, lx: look.x, ly: look.y}; }
        });
        document.addEventListener('pointermove', e => {
            if(interact) {
                look.x = start.lx + (start.x - e.clientX) * 0.2;
                look.y = start.ly + (e.clientY - start.y) * 0.2;
            }
        });
        document.addEventListener('pointerup', () => interact = false);

        const keys = {};
        window.onkeydown = e => keys[e.key.toLowerCase()] = true;
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;

        function checkCol(pos) {
            return (Math.abs(pos.x) > 9.5 || Math.abs(pos.z) > 9.5);
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            const pos = rainSys.geometry.attributes.position.array;
            for(let i=1; i<pos.length; i+=3) {
                pos[i] -= 0.3;
                if(pos[i] < 0) pos[i] = 20;
            }
            rainSys.geometry.attributes.position.needsUpdate = true;

            lights.forEach((obj, i) => {
                obj.l.intensity = 150 + Math.sin(time*3 + i)*50;
            });

            look.y = Math.max(-85, Math.min(85, look.y));
            const phi = THREE.MathUtils.degToRad(90 - look.y);
            const theta = THREE.MathUtils.degToRad(look.x);
            const target = new THREE.Vector3().setFromSphericalCoords(1, phi, theta).add(camera.position);
            camera.lookAt(target);

            let f = move.f, r = move.r;
            if(keys['w']) f += 1; if(keys['s']) f -= 1;
            if(keys['d']) r += 1; if(keys['a']) r -= 1;

            if(f || r) {
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
                const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();
                const next = camera.position.clone().addScaledVector(dir, f * 5 * dt).addScaledVector(side, -r * 5 * dt);
                
                if(!checkCol(next)) camera.position.copy(next);
            }

            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
